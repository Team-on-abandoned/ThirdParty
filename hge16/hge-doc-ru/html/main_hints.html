<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- http://hge.relishgames.com -->

<html>

<head>
<meta name="Keywords" content="game engine, 2d, hardware accelerated, hge, engine, relish games, game development">
<meta name="Description" content="Haaf's Game Engine - Hardware accelerated 2D games engine">
<title>Haaf's Game Engine - Игровой 2D движок с поддержкой аппаратного ускорения</title>
<link rel=stylesheet type=text/css href=hge.css>
<script language="JavaScript" src="hge.js"></script>
</head>

<body onload="setContents('cnt_main.html');" bgcolor=#ffffff text=#000000 link=#7F0000 vlink=#7F0000 alink=#7F0000 marginwidth=0 marginheight=0 leftmargin=0 topmargin=0>
<table height=100% cellspacing=0 cellpadding=0 border=0><tr>

<td valign=top>
<table width=566 cellspacing=0 cellpadding=20 border=0><tr><td>
<h1 style="margin-top:0px">Полезные советы</h1>
<h2>Поддержка видеокарт</h2>
<p>
<b>HGE</b> запустится даже на low-end видеокартах, включая встроенные видеокарты, такие как <b>Intel Solano</b> (i815 chipset).
</p>
<h2>Последовательности</h2>
<p>
В целях повышения производительности функции <a href="hgefunc_gfxrenderline.html">Gfx_RenderLine</a>,
<a href="hgefunc_gfxrendertriple.html">Gfx_RenderTriple</a> и <a href="hgefunc_gfxrenderquad.html">Gfx_RenderQuad</a>
накапливают смежные примитивы с одинаковой текстурой и режимом смешивания и затем отображают из 
одним вызовом <b>DirectX</b>. В большинстве случаев вы не заметите разницы или вообще не будете 
пользоваться последовательностями вообще. Но на всякий случай рекомендуется группировать вызовы 
рисования примитивов сначала по типу примитивов, затем по текстуре и наконец по режиму смешивания. 
Так же можно пользоваться функциями <a href="hgefunc_gfxstartbatch.html">Gfx_StartBatch</a>
и <a href="hgefunc_gfxfinishbatch.html">Gfx_FinishBatch</a> для самого быстрого вывода больших 
массивов примитивов.
</p>
<h2>Размеры текстур</h2>
<p>
Величина размеров любой текстуры должны должна быть степерью 2. Не рекомендуется использовать 
текстуры размером больше 1024x1024, потому что они могут работать очень медленно в некоторых 
видеокартах, которые не поддерживают их напрямую. Постарайтесь также помещать свою графику на несколько
больших текстур, чтобы уменьшить количество их смен, что влияет на производительность.
</p>
<h2>Использование Z-буфера</h2>
<p>
Используйте Z-буфер только если он необходим, так как это влияет на производительность. По умолчанию 
Z-буфер отключен. Чтобы его включить, установите параметр системы <a href="hgeconst_systemstate.html#HGE_ZBUFFER">HGE_ZBUFFER</a> 
в значение <b>true</b> с помошью вызова функции <a href="hgefunc_systemsetstate.html">System_SetState</a>.
Когда Z-буфер включен, лучше не производить сортировку объектов по убыванию, что повысит 
производительность.
</p>
<h2>Очистка экрана</h2>
<p>
Очищайте экран только в случае, когда это необходимо, потому что это влияет на производительность. 
Если вы покрываете объектами весь экран в каждом кадре - нет необходимости его очищать. В случае, 
если вы пользуетесь Z-буфером, возможно вым все равно придется очищать экран, чтобы сбросить его.
</p>
<h2>Масштабирование и вращение</h2>
<p>
Если вы собираетесь масштабировать или вращать свои спрайты - убедителсь, что графика постирается 
хотябы на 1 пиксел ниже альфа маски и/или границы ограничиывющего прямоугольника, чтобы избежать 
искажений.
<p>
</p>
<h2>Библиотеки спрайты и тайлов</h2>
<p>
Вы можете использовать вспомогательный класс <a href="hgeanim__main.html">hgeAnimation</a> в
качестве библиотеки спрайтов или тайлов. Просто не вызывайте метод <a href="hgeanim_update.html">Update</a> 
и выбирайте нужный спрайт вручную используя метод <a href="hgeanim_setframe.html">SetFrame</a>.
</p>
<h2>Клонирование</h2>
<p>
Можете использовать оператор присваивания (=) или конструктор копий, чтобы клонировать экземпляры 
большинства вспомогательных классов. Например, в случае с указателями на спрайты, синтаксис будет 
выглядеть так: <b>*sprite2=*sprite1;</b> или так <b>hgeSprite *sprite2=new hgeSprite(*sprite1);</b>
Исключением являются классы <a href="hgegui__main.html">hgeGUI</a>, <a href="hgeresource__main.html">hgeResourceManager</a> 
и <a href="hgepmanager__main.html">hgeParticleManager</a>.
</p>
<h2>Меш искажения и спрайты без текстуры</h2>
<p>
Вы можете использовать экземпляры классов <a href="hgedistort__main.html">hgeDistortionMesh</a>
и <a href="hgesprite__main.html">hgeSprite</a> без присоединенной к ним текстур, чтобы получить 
цветовые эффекты на всю сцену, или ее часть. Попробуйте режим смешивания <a href="hgeconst_blendmode.html">BLEND_ALPHAADD</a>.
</p>
<h2>Отображение курсора мыши</h2>
<p>
Чтобы отобразить курсор мыши, выводите все что захочется по координатам, полученным функцией <a href="hgefunc_inputgetmousepos.html">Input_GetMousePos</a>
в функции кадра.
</p>
<h2>Использование внешних функций работы со звуком</h2>
<p>
Если вы не желаете использовать звуковую библиотеку <b>BASS</b> для работы со звуком и хотите 
применить свою собственную реализацию звуковой системы, установите параметр системы <a href="hgeconst_systemstate.html#HGE_USESOUND">HGE_USESOUND</a> 
в значение <b>false</b> вызовом функции <a href="hgefunc_systemsetstate.html">System_SetState</a>
перед вызовом <a href="hgefunc_systeminitiate.html">System_Initiate</a>. Так же позаботьтесь о <b>BASS.DLL</b>.
</p>
<h2>Управление указателем на интерфейс HGE</h2>
<p>
В любой момент, когда вам нужен доступ к <b>HGE</b>, вы можете вызвать функцию <a href="hgefunc_interfaceget.html">hgeCreate</a>
и затем использовать полученный указатель, а затем освобождать его с помощью <a href="hgefunc_interfacerelease.html">Release</a>.
Или вы можете получить указатель на интерфейс в начале программы и сохранить его в глобальную 
переменную и освобождать в момент закрытия приложения. Хотя последний способ является 'плохим стилем',
 он работает в небольших проектах и все вспомогательные классы <b>HGE</b> используют этот подход.
</p>
<h2>Преобразоваение float к int</h2>
<p>
Если в вашем коде присутствует большое количество преобразований от  <b>float</b> к <b>int</b> 
можете попробовать использовать ключ <b>/QIfist</b> компилятора <b>Visual C++</b>. Если включена эта 
функция можно получить улучшение производительности, хотя нельзя быть уверенным, какой способ 
округления будет использован. Чтобы активировать эту опцию, напишите ее в текстовом окне <b>Project Options</b> 
в закладке <b>Project->Settings...->C/C++</b> диалога настроек debug и release конфигураций. Если вы 
используете другой компилятор, необходимо найти похожую опцию быстрого преобразования от <b>float</b> 
к <b>int</b> в сети, взамен стандартного преобразования.
</p>
<h2>Синхронизация скорости</h2>
<p>
Чтобы сделать игру независимой от скорости выполнения, масштабируйте все внутренние значения 
скоростей по значению, полученному функцией <a href="hgefunc_timergetdelta.html">Timer_GetDelta</a>. 
Если вы используете ускорение или другие нелинейные функции, могут возникнуть проблемы: 
аппроксимация линейными сегментами может дать разные результаты, в зависимости от числа сегментов. 
Чтобы этого избежать, накапливайте значения, полученные функцией <a href="hgefunc_timergetdelta.html">Timer_GetDelta</a> 
и обновляйте свои функции в фиксированные интервалы, или просто установите параметр системы 
<a href="hgeconst_systemstate.html#HGE_FPS">HGE_FPS</a>.
</p>
<h2>Ресурсы</h2>
<p>
Во время разработки, вы можете хранить свои данные в виде простых файлов на диске. Затем просто 
соберите архив с ресурсами при помощи <b>pkzip</b> и присоедините его вызовом функции
<a href="hgefunc_resourceattachpack.html">Resource_AttachPack</a>. Никаких дополнительных изменений 
в коде не понадобится для использования архива ресурсов. Смотрите также секцию 
<a href="main_respack.html">Compiling resource pack</a>, для более подробной информации.
</p>
<br>
</td></tr></table>
</td>

</tr></table>
</body>

</html>
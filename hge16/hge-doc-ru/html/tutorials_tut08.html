<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- http://hge.relishgames.com -->

<html>

<head>
<meta name="Keywords" content="game engine, 2d, hardware accelerated, hge, engine, relish games, game development">
<meta name="Description" content="Haaf's Game Engine - Hardware accelerated 2D games engine">
<title>Haaf's Game Engine - Игровой 2D движок с поддержкой аппаратного ускорения</title>
<link rel=stylesheet type=text/css href=hge.css>
<script language="JavaScript" src="hge.js"></script>
</head>

<body onload="setContents('cnt_tutorials.html');" bgcolor=#ffffff text=#000000 link=#7F0000 vlink=#7F0000 alink=#7F0000 marginwidth=0 marginheight=0 leftmargin=0 topmargin=0>
<table height=100% cellspacing=0 cellpadding=0 border=0><tr>

<td valign=top>
<table width=566 cellspacing=0 cellpadding=20 border=0><tr><td>
<h1 style="margin-top:0px">Пример 08 - Полный штиль</h1>
<p>
<b>Э</b>тот пример демонстрирует использование специальных эффектов и моделирования сложного 
освещение.
<br><br>
<img src="t08_1.gif" width=150 height=113>&nbsp;&nbsp;
<img src="t08_2.gif" width=150 height=113>&nbsp;&nbsp;
<img src="t08_3.gif" width=150 height=113>&nbsp;&nbsp;
</p>
<h2>Оттенки Неба</h2>
<p>
Чтобы нарисовать небо мы будем пользоваться спрайтом без текстуры:
</p>
<pre>
hgeSprite *sky;

sky=new hgeSprite(0, 0, 0, SCREEN_WIDTH, SKY_HEIGHT);
</pre>
<p>
Его верхние и нижние вершины окрашены в разные цвета, плавно переходящие друг в друга:
</p>
<pre>
hgeColor colSkyTop;
hgeColor colSkyBtm;

sky->SetColor(colSkyTop.GetHWColor(), 0);
sky->SetColor(colSkyTop.GetHWColor(), 1);
sky->SetColor(colSkyBtm.GetHWColor(), 2);
sky->SetColor(colSkyBtm.GetHWColor(), 3);
sky->Render(0, 0);
</pre>
<p>
Цвет неба зависит от времени суток и вычисляются посредствам интерполяции между несколькими 
константными значениями:
</p>
<pre>
hgeColor col1, col2;

col1.SetHWColor(skyTopColors[seq[seq_id]]);
col2.SetHWColor(skyTopColors[seq[seq_id+1]]);
colSkyTop=col2*seq_residue + col1*(1.0f-seq_residue);

col1.SetHWColor(skyBtmColors[seq[seq_id]]);
col2.SetHWColor(skyBtmColors[seq[seq_id+1]]);
colSkyBtm=col2*seq_residue + col1*(1.0f-seq_residue);
</pre>
<h2>Море и Волны</h2>
<p>
Похожая техника раскрашивания применяется и для моря. Но в этот раз мы воспользуемся классом 
<a href="hgedistort__main.html">hgeDistortionMesh</a> вместо класса <a href="hgesprite__main.html">hgeSprite</a> 
для моделирования волн:
</p>
<pre>
hgeDistortionMesh *sea;

sea=new hgeDistortionMesh(SEA_SUBDIVISION, SEA_SUBDIVISION);
sea->SetTextureRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT-SKY_HEIGHT);
</pre>
<p>
Чтобы создать водны, мы установим перемещение и окраску для каждого узла сетки искажения (мы опустим 
первую и последнюю строчки так как мы не хотим, чтобы они двигались):
</p>
<pre>
for(i=1; i&lt;SEA_SUBDIVISION-1; i++)
{
  <font color=#008000>// these are constants for each vertices line</font>
  a=float(i)/(SEA_SUBDIVISION-1);
  col1=colSeaTop*(1-a)+colSeaBtm*a;
  dwCol1=col1.GetHWColor();
  fTime=2.0f*hge->Timer_GetTime();
  a*=20;

  for(j=0; j&lt;SEA_SUBDIVISION; j++)
  {
    sea->SetColor(j, i, dwCol1);
    dy=a*sinf(seaP[i]+ <font color=#008000>// precalculated phase shift</font>
         (float(j)/(SEA_SUBDIVISION-1)-0.5f)*M_PI*16.0f-fTime);
    sea->SetDisplacement(j, i, 0.0f, dy, HGEDISP_NODE);
  }
}
</pre>
<p>
Теперь установим окраску для пропущеных первой и последней строк узлов сетки искажения:
</p>
<pre>
dwCol1=colSeaTop.GetHWColor();
dwCol2=colSeaBtm.GetHWColor();

for(j=0; j&lt;SEA_SUBDIVISION; j++)
{
  sea->SetColor(j, 0, dwCol1);
  sea->SetColor(j, SEA_SUBDIVISION-1, dwCol2);
}
</pre>
<p>
Теперь море готово и мы рисуем его одним единсвтенным вызовом:
</p>
<pre>
sea->Render(0, SKY_HEIGHT);
</pre>
<p>
В настоящем исходном коде еше добавлена эмуляция луны и солнца. Чтобы это сделать, мы просто добавим 
немного белый окрас в узлы сетки искажения которые находятся прямо под солцем/луной.
</p>
<h2>Небесные Тела</h2>
<p>
Звезды, луна и солнце являются просто масштабированными и подкрашенными спрайтами:
</p>
<pre>
hgeSprite *sun;
hgeSprite *moon;
hgeSprite *star;

sun=new hgeSprite(texObjects,81,0,114,114);
sun->SetHotSpot(57,57);
moon=new hgeSprite(texObjects,0,0,81,81);
moon->SetHotSpot(40,40);
star=new hgeSprite(texObjects,72,81,9,9);
star->SetHotSpot(5,5);
</pre>
<p>
Интересная деталь - хало и отражения на поверхности воды. Это тоже обычные спрайты:
</p>
<pre>
hgeSprite *glow;
hgeSprite *seaglow;

glow=new hgeSprite(texObjects,128,128,128,128);
glow->SetHotSpot(64,64);
glow->SetBlendMode(BLEND_COLORADD | BLEND_ALPHABLEND);

seaglow=new hgeSprite(texObjects,128,224,128,32);
seaglow->SetHotSpot(64,0);
seaglow->SetBlendMode(BLEND_COLORADD | BLEND_ALPHAADD);
</pre>
<p>
Заметьте, что спрайты хало различаются методами смешивания, чтобы достичь правильных цветов. Так же 
заметьте, что оба спрайта делять одну и туже область текстуры.
<br><br>
Позиция солнца и луны, масштабирование и окраска вычисляются в функции <b>UpdateSimulation</b> 
и затем все объекты отображаются в функции <b>RenderSimulation</b>:
</p>
<pre>
glow->SetColor(colSunGlow.GetHWColor());
glow->RenderEx(sunX, sunY, 0.0f, sunGlowS);
sun->SetColor(colSun.GetHWColor());
sun->RenderEx(sunX, sunY, 0.0f, sunS);

glow->SetColor(colMoonGlow.GetHWColor());
glow->RenderEx(moonX, moonY, 0.0f, moonGlowS);
moon->SetColor(colMoon.GetHWColor());
moon->RenderEx(moonX, moonY, 0.0f, moonS);
</pre>
<p>
Тоже самое для отражений на море:
</p>
<pre>
seaglow->SetColor(colSeaGlow.GetHWColor());
seaglow->RenderEx(seaGlowX, SKY_HEIGHT,
                     0.0f, seaGlowSX, seaGlowSY);
</pre>
<p>
Заметьте, что спрайт отражения на море масштабируется не пропорционально.
</p>
<h2>Производительность</h2>
<p>
Несмотря на видимую сложность, этот пример выполняется с довольно высоким FPS. Это становится
возможным благодаря выводу спрайтов через <b>Direct3D</b>, узким местом является пропускная
способность текстур. И этот пример рисует всего лишь несколько спрайтов из маленькой текстуры.
Большие области экрана заполняются сплошным цветом.
</p>
<p>
Полный исходный код с детальными комментариями для этого примера вы можете найти в директории <b>tutorials\tutorial08</b>. 
Требуемые медиа файлы можно найти в директории <b>tutorials\precompiled</b>.
</p>
<p>
Используйте клавиши <b>1</b> по <b>9</b> чтобы изменить скорость воспроизведения, <b>0</b> для 
реального времени и <b>ESC</b> чтобы выйти.
</p>
<br>
</td></tr></table>
</td>

</tr></table>
</body>

</html>